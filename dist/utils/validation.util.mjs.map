{"version":3,"file":"validation.util.mjs","sources":["../../src/lib/utils/validation.util.js"],"sourcesContent":["/*\nCopyright 2022 Iguazio Systems Ltd.\nLicensed under the Apache License, Version 2.0 (the \"License\") with\nan addition restriction as set forth herein. You may not use this\nfile except in compliance with the License. You may obtain a copy of\nthe License at http://www.apache.org/licenses/LICENSE-2.0.\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\nimplied. See the License for the specific language governing\npermissions and limitations under the License.\nIn addition, you may not use the software for any purposes that are\nillegal under applicable law, and the grant of the foregoing license\nunder the Apache 2.0 license is conditioned upon your compliance with\nsuch restriction.\n*/\nimport lodash, { isEmpty } from 'lodash'\n\nimport { validation as ValidationConstants } from '../constants'\n\n////// PRIVATE METHODS ///////\n\n/**\n * Converts characters string to readable format\n * Note: converts Hyphens to En Dashes, replaces one space with comma and space,\n *       replaces letter `s` with `spaces` word\n * @param {string} chars - characters to convert\n * @returns {string} - converted string\n * @example\n * convertToLabel('a-z A-Z - _ *');\n * // => 'a–z, A–Z, –, _, *'\n */\nconst convertToLabel = chars => {\n  return chars.replace(/-/g, '–').replace(/\\s/g, ', ').replace(/\\bs\\b/, 'spaces')\n}\n\n/**\n * Converts characters string to valid RegExp string that will be placed into RegExp pattern\n * @param {string} chars - characters to convert\n * @returns {string} - converted string\n * @example\n * convertToPattern('a-z A-Z - _ *') => 'a-zA-Z\\-\\_\\*'\n */\nconst convertToPattern = chars => {\n  return chars\n    .split(' ')\n    .map(patternItem => (patternItem.length === 1 ? '\\\\' + patternItem : patternItem))\n    .join('')\n}\n\n/**\n * Checks whether there is at least one failed validation rule.\n * @returns {boolean} `true` in case there is at least one failed validation rule, or `false` otherwise.\n */\nconst hasInvalidRule = newRules => {\n  return lodash.some(newRules, ['isValid', false])\n}\n\n////// PUBLIC METHODS ///////\n\n/**\n * validate required field value\n * @param {string} validationMsg Custom validationMsg. Defualt to \"Required\"\n * @returns {function}  Function that accepts a value and return an array [isFieldValid, validationMsg]\n */\n\nexport const required =\n  (validationMsg = 'Required') =>\n  value => {\n    let isValid = value.trim() !== '' && typeof value === 'string'\n    return [isValid, validationMsg]\n  }\n\n/**\n * Checks whether there is at least one failed validation rule.\n * @function checkPatternsValidity\n * @param {Array} validationRules Array of Validation Rule Objects {name: \"\", lable: \"\", pattren: [Function || Regex]}\n * @param {string} value Field value to check validity\n * @param {boolean} required Specified if the value should be validated\n * @returns {Array} [validationRules, isFieldValid] New validationRules With `isValid` property, `true` in case there is at least one failed validation rule, or `false` otherwise.\n */\n\nexport const checkPatternsValidity = (validationRules, value = '', required = true) => {\n  const newRules =\n    !required && isEmpty(value)\n      ? validationRules\n      : validationRules\n          .filter(rule => !rule.async)\n          .map(rule => {\n            return {\n              ...rule,\n              isValid: lodash.isFunction(rule.pattern)\n                ? rule.pattern(value)\n                : /* else, it is a RegExp */ rule.pattern.test(value)\n            }\n          })\n\n  return [newRules, !hasInvalidRule(newRules)]\n}\n\nexport const checkPatternsValidityAsync = async (validationRules, value) => {\n  const [newRules] = checkPatternsValidity(validationRules, value)\n  const asyncRules = await Promise.all(\n    validationRules\n      .filter(rule => rule.async)\n      .map(async rule => ({\n        ...rule,\n        isValid: await rule.pattern(value)\n      }))\n  )\n\n  const allRules = newRules.concat(asyncRules)\n\n  return [allRules, !hasInvalidRule(allRules)]\n}\n\nconst generateRule = {\n  beginWith: chars => {\n    return {\n      name: ValidationConstants.BEGIN_WITH.NAME,\n      label: ValidationConstants.BEGIN_WITH.LABEL + ': ' + convertToLabel(chars),\n      pattern: new RegExp('^[' + convertToPattern(chars) + ']')\n    }\n  },\n  beginNotWith: chars => {\n    return {\n      name: ValidationConstants.BEGIN_NOT_WITH.NAME,\n      label: ValidationConstants.BEGIN_NOT_WITH.LABEL + ': ' + convertToLabel(chars),\n      pattern: new RegExp('^[^' + convertToPattern(chars) + ']')\n    }\n  },\n  endWith: chars => {\n    return {\n      name: ValidationConstants.END_WITH.NAME,\n      label: ValidationConstants.END_WITH.LABEL + ': ' + convertToLabel(chars),\n      pattern: new RegExp('[' + convertToPattern(chars) + ']$')\n    }\n  },\n  endNotWith: chars => {\n    return {\n      name: ValidationConstants.END_NOT_WITH.NAME,\n      label: ValidationConstants.END_NOT_WITH.LABEL + ': ' + convertToLabel(chars),\n      pattern: new RegExp('[^' + convertToPattern(chars) + ']$')\n    }\n  },\n  beginEndWith: (chars, labelPrefix = '') => {\n    const convertedPattern = convertToPattern(chars)\n\n    return {\n      name: ValidationConstants.BEGIN_END_WITH.NAME,\n      label: labelPrefix + ValidationConstants.BEGIN_END_WITH.LABEL + ': ' + convertToLabel(chars),\n      pattern: new RegExp('^([' + convertedPattern + '].*)?[' + convertedPattern + ']$')\n    }\n  },\n  beginEndNotWith: chars => {\n    const convertedPattern = convertToPattern(chars)\n\n    return {\n      name: ValidationConstants.BEGIN_END_NOT_WITH.NAME,\n      label: ValidationConstants.BEGIN_END_NOT_WITH.LABEL + ': ' + convertToLabel(chars),\n      pattern: new RegExp('^([^' + convertedPattern + '].*)?[^' + convertedPattern + ']$')\n    }\n  },\n  onlyAtTheBeginning: chars => {\n    const convertedPattern = convertToPattern(chars)\n\n    return {\n      name: ValidationConstants.ONLY_AT_THE_BEGINNING.NAME,\n      label: ValidationConstants.ONLY_AT_THE_BEGINNING.LABEL + ': ' + convertToLabel(chars),\n      pattern: new RegExp('^([' + convertedPattern + '])?[^' + convertedPattern + ']+$')\n    }\n  },\n  validCharacters: (chars, labelPrefix = '') => {\n    return {\n      name: ValidationConstants.VALID_CHARACTERS.NAME,\n      label:\n        labelPrefix + ValidationConstants.VALID_CHARACTERS.LABEL + ': ' + convertToLabel(chars),\n      pattern: new RegExp('^[' + convertToPattern(chars) + ']+$')\n    }\n  },\n  validCharactersWithPrefix: chars => {\n    return {\n      name: ValidationConstants.VALID_CHARACTERS_WITH_REFIX.NAME,\n      label: ValidationConstants.VALID_CHARACTERS_WITH_REFIX.LABEL + ': ' + convertToLabel(chars),\n      pattern: new RegExp(\n        '^([' + convertToPattern(chars) + ']+/)?[' + convertToPattern(chars) + ']+$'\n      )\n    }\n  },\n  noConsecutiveCharacters: chars => {\n    const convertedPattern = chars\n      .split(' ')\n      .map(charPair => {\n        const charsPairArray = charPair.split('')\n\n        return `(?!.*\\\\${charsPairArray[0]}\\\\${charsPairArray[1]})`\n      })\n      .join('')\n\n    return {\n      name: ValidationConstants.NO_CONSECUTIVE_CHARACTER.NAME,\n      label: ValidationConstants.NO_CONSECUTIVE_CHARACTER.LABEL + ': ' + convertToLabel(chars),\n      pattern: new RegExp('^' + convertedPattern)\n    }\n  },\n  notContainCharacters: chars => {\n    return {\n      name: ValidationConstants.NOT_CONTAIN.NAME,\n      label: ValidationConstants.NOT_CONTAIN.LABEL + ': ' + convertToLabel(chars),\n      pattern: new RegExp('^[^' + convertToPattern(chars) + ']+$')\n    }\n  },\n  maxLengthBetweenDelimiters: (delimiter, maxLength, delimiterDescription) => {\n    return {\n      name: 'labelsLength',\n      label: `Max length between two ${lodash.defaultTo(\n        delimiterDescription,\n        delimiter\n      )}: ${maxLength}`,\n      pattern: value => {\n        return value.split(delimiter).every(item => {\n          return item.length >= 1 && item.length <= maxLength\n        })\n      }\n    }\n  },\n  mustNotBe: words => {\n    const wordsArray = words.split(' ')\n\n    return {\n      name: ValidationConstants.MUST_NOT_BE.NAME,\n      label: ValidationConstants.MUST_NOT_BE.LABEL + ': ' + convertToLabel(words),\n      pattern: function (value) {\n        return !lodash.includes(wordsArray, value)\n      }\n    }\n  },\n  length: (options, labelPrefix = '') => {\n    const min = Number.isSafeInteger(options.min) ? options.min : 0\n    const max = Number.isSafeInteger(options.max) ? options.max : ''\n\n    if (min || max) {\n      const label =\n        'Length – ' +\n        (min ? 'min: ' + options.min + '\\xa0\\xa0' : '') +\n        (max ? 'max: ' + options.max : '')\n\n      return {\n        name: 'length',\n        label: labelPrefix + label,\n        pattern: new RegExp('^[\\\\S\\\\s]{' + min + ',' + max + '}$')\n      }\n    }\n  },\n  required: () => {\n    return {\n      name: ValidationConstants.REQUIRED.NAME,\n      label: ValidationConstants.REQUIRED.LABEL,\n      pattern: new RegExp('\\\\S')\n    }\n  }\n}\n\nconst commonRules = {\n  prefixedQualifiedName: [\n    {\n      name: 'nameValidCharacters',\n      label: `[Name] ${ValidationConstants.VALID_CHARACTERS.LABEL} : a–z, A–Z, 0–9, –, _, .`,\n      pattern: /^([^/]+\\/)?[\\w.-]+$/\n    },\n    {\n      name: 'nameBeginEnd',\n      label: `[Name] ${ValidationConstants.BEGIN_END_WITH.LABEL}: a–z, A–Z, 0–9`,\n      pattern: /^([^/]+\\/)?([A-Za-z0-9][^/]*)?[A-Za-z0-9]$/\n    },\n    {\n      name: 'nameMaxLength',\n      label: '[Name] Max length - 63 characters',\n      pattern: /^([^/]+\\/)?[^/]{1,63}$/\n    },\n    {\n      name: 'prefixValidCharacters',\n      label: `[Prefix] ${ValidationConstants.VALID_CHARACTERS.LABEL}: a–z, 0–9, –, .`,\n      pattern: /^([a-z0-9.-]+\\/)?[^/]+$/\n    },\n    {\n      name: 'prefixBeginEnd',\n      label: `[Prefix] ${ValidationConstants.BEGIN_END_WITH.LABEL}: a–z, 0–9`,\n      pattern: /^([a-z0-9]([^/]*[a-z0-9])?\\/)?[^/]+$/\n    },\n    {\n      name: 'prefixMaxLength',\n      label: '[Prefix] Max length - 253 characters',\n      pattern: /^(?![^/]{254,}\\/)/\n    }\n  ],\n  k8sLabels: {\n    getValue: (withPrefix = false) => {\n      let labelPrefix = withPrefix ? '[Value] ' : ''\n\n      return [\n        generateRule.beginEndWith('a-z A-Z 0-9', labelPrefix),\n        generateRule.length({ max: 63 }, labelPrefix),\n        generateRule.validCharacters('a-z A-Z 0-9 - _ .', labelPrefix)\n      ]\n    }\n  }\n  // email: [\n  //   generateRule.beginEndNotWith('@ .'),\n  //   {\n  //     name: ValidationConstants.MUST_CONTAIN_EXACTLY_ONE.NAME,\n  //     label: ValidationConstants.MUST_CONTAIN_EXACTLY_ONE.LABEL + ': @',\n  //     pattern: /^[^@]+@[^@]+$/\n  //   },\n  //   {\n  //     name: ValidationConstants.MUST_HAVE_DOT_AFTER_AT.NAME,\n  //     label: ValidationConstants.MUST_HAVE_DOT_AFTER_AT.LABEL,\n  //     pattern: /@.+\\..+$/\n  //   }\n  // ]\n}\n\ncommonRules.k8sLabels.key = commonRules.prefixedQualifiedName.concat({\n  name: 'prefixNotStart',\n  label: \"[Prefix] Must not start with 'kubernetes.io', 'k8s.io'\",\n  pattern: /^(?!kubernetes\\.io\\/)(?!k8s\\.io\\/)/\n})\n\nconst validationRules = {\n  artifact: {\n    name: [\n      generateRule.validCharacters('a-z A-Z 0-9 - _ .'),\n      generateRule.beginEndWith('a-z A-Z 0-9'),\n      generateRule.length({ max: 253 }),\n      generateRule.required()\n    ],\n    labels: {\n      key: [\n        generateRule.notContainCharacters(':'),\n        generateRule.beginEndWith('a-z A-Z 0-9'),\n        generateRule.length({ max: 255 })\n      ],\n      value: [generateRule.beginEndWith('a-z A-Z 0-9'), generateRule.length({ max: 255 })]\n    }\n  },\n  feature: {\n    sets: {\n      tag: [\n        generateRule.validCharacters('a-z A-Z 0-9 - _'),\n        generateRule.beginEndWith('a-z A-Z 0-9'),\n        generateRule.length({ max: 56 })\n      ]\n    },\n    vector: {\n      name: [\n        generateRule.validCharacters('a-z A-Z 0-9 - _ .'),\n        generateRule.beginEndWith('a-z A-Z 0-9'),\n        generateRule.length({ max: 56 }),\n        generateRule.required()\n      ]\n    }\n  },\n  function: {\n    name: [\n      generateRule.validCharacters('a-z 0-9 - .'),\n      generateRule.beginEndWith('a-z 0-9'),\n      generateRule.length({ max: 63 }),\n      generateRule.required()\n    ]\n  },\n  common: {\n    name: [\n      generateRule.validCharacters('a-z A-Z 0-9 - _ .'),\n      generateRule.beginEndWith('a-z A-Z 0-9'),\n      generateRule.length({ max: 63 }),\n      generateRule.required()\n    ],\n    tag: [\n      generateRule.validCharacters('a-z A-Z 0-9 - _ .'),\n      generateRule.beginEndWith('a-z A-Z 0-9'),\n      generateRule.length({ max: 56 })\n    ],\n    combobox: [generateRule.required()]\n  },\n  project: {\n    name: [\n      generateRule.validCharacters('a-z 0-9 -'),\n      generateRule.beginWith('a-z'),\n      generateRule.endWith('a-z 0-9'),\n      generateRule.length({ max: 63 }),\n      generateRule.required()\n    ],\n    labels: {\n      key: commonRules.k8sLabels.key,\n      value: commonRules.k8sLabels.getValue(true)\n    },\n    params: {\n      key: [generateRule.notContainCharacters('s')],\n      value: [generateRule.beginEndNotWith('s')]\n    },\n    secrets: {\n      key: [generateRule.validCharacters('a-z A-Z 0-9 - _ .')]\n    }\n  },\n  nodeSelectors: {\n    key: commonRules.prefixedQualifiedName,\n    value: commonRules.k8sLabels.getValue(false)\n  },\n  environmentVariables: {\n    secretName: [\n      generateRule.validCharacters('a-z A-Z 0-9 - _ .'),\n      generateRule.beginEndWith('a-z A-Z 0-9'),\n      generateRule.noConsecutiveCharacters('.., .–, –.'),\n      generateRule.maxLengthBetweenDelimiters(/[.\\-_]/, 63, 'periods'),\n      generateRule.length({ max: 253 }),\n      generateRule.required()\n    ],\n    secretKey: [\n      generateRule.validCharacters('a-z A-Z 0-9 - _ .'),\n      generateRule.beginNotWith('.'),\n      generateRule.length({ max: 253 })\n    ]\n  },\n  job: {\n    label: {\n      key: [\n        generateRule.validCharactersWithPrefix('a-z A-Z 0-9 - _ .'),\n        generateRule.beginEndWith('a-z A-Z 0-9'),\n        generateRule.length({ max: 75 })\n      ],\n      value: generateRule.length({ max: 255 })\n    }\n  }\n}\n\n/**\n * Returns the list of validation rules for `type`, optionally appending provided additional rules.\n * @function getValidationRules\n * @param {string} type - The property path to the list of validation rules.\n * @param {Array.<Object> | Object} [additionalRules] - Additional rules or rule to append.\n * @returns {Array.<Object>} The rule list of type `type` with `additionalRules` appended to it if provided.\n */\nexport const getValidationRules = (type, additionalRules) => {\n  return lodash\n    .chain(validationRules)\n    .get(type)\n    .defaultTo([])\n    .cloneDeep()\n    .concat(lodash.defaultTo(additionalRules, []))\n    .value()\n}\n\n/**\n * Creates a validation rule to ensure system-defined labels cannot be modified.\n * @function getInternalLabelsValidationRule\n * @param {string} internalLabels - An array of defined labels that should not be modified.\n * @returns {Object} The rule that checks if a value is not in the internal labels.\n */\nexport const getInternalLabelsValidationRule = (internalLabels = []) => {\n  return {\n    name: 'customLabels',\n    label: 'System-defined labels cannot be modified.',\n    pattern: value => {\n      return !internalLabels.includes(value)\n    }\n  }\n}\n"],"names":["convertToLabel","chars","convertToPattern","patternItem","hasInvalidRule","newRules","lodash","required","validationMsg","value","checkPatternsValidity","validationRules","isEmpty","rule","checkPatternsValidityAsync","asyncRules","allRules","generateRule","ValidationConstants","labelPrefix","convertedPattern","charPair","charsPairArray","delimiter","maxLength","delimiterDescription","item","words","wordsArray","options","min","max","label","commonRules","withPrefix","getValidationRules","type","additionalRules","getInternalLabelsValidationRule","internalLabels"],"mappings":"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"}